<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>hdict.data.aux_frozendict API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>hdict.data.aux_frozendict</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from itertools import chain
from typing import Dict
from typing import TypeVar

from hosh import ø

from hdict import hdict, value, frozenhdict, Self
from hdict.abs import AbsAny
from hdict.content.argument.apply import apply
from hdict.content.argument.field import field
from hdict.content.argument.sample import sample
from hdict.content.entry import AbsEntry
from hdict.content.entry.closure import Closure
from hdict.dataset.dataset import df2Xy
from hdict.expression.step.applyout import ApplyOut

VT = TypeVar(&#34;VT&#34;)


class MissingFieldException(Exception):
    pass


def handle_items(*datas: [Dict[str, object]], previous: frozenhdict):
    result = {} if previous is None else previous.raw.copy()
    result__mirror_fields = {}
    for key, item in chain(*(data.items() for data in datas)):
        entry = handle_item(key, item, result, previous)
        if isinstance(key, str) and key.endswith(&#34;_&#34;):
            if isinstance(entry, value):
                result__mirror_fields[f&#34;{key[:-1]}&#34;] = value(entry.hdict, entry.hdict.hosh)
            else:
                raise Exception(f&#34;lazy mirror?&#34;)  # todo:
        if isinstance(entry, dict):
            result.update(entry)
        else:
            result[key] = entry
    result.update(result__mirror_fields)
    return result


def handle_item(key, item, result, previous):
    from hdict.content.argument.entry import entry

    match item:
        case AbsEntry():
            res = item
        case field(name=name):
            if name not in result:  # pragma: no cover
                raise MissingFieldException(f&#34;Missing field `{name}`&#34;)
            res = handle_item(name, result[name], result, previous)
        case entry(name=name):
            from hdict.content.entry.wrapper import Wrapper

            if name not in result:  # pragma: no cover
                raise MissingFieldException(f&#34;Missing entry `{name}`&#34;)
            res = Wrapper(handle_item(name, result[name], result, previous))
        case apply():
            res = item.enclosure(result, key, previous)
        case sample():  # pragma: no cover
            raise Exception(f&#34;Unsampled variable or argument `{key}`&#34;)
        case frozenhdict():
            res = value(item, item.hosh)
        case hdict():
            res = value(item.frozen, item.hosh)
        case ApplyOut():  # pragma: no cover
            raise Exception(&#34;Cannot assign output through both apply and dict-key: &#39;&gt;&gt; {out: apply(...)(out)}&#39;.&#34;)
        case Self():
            if previous is None:
                raise Exception(f&#34;Cannot reference self in a new hdict. `_` is intended to point to a hdict before application.&#34;)
            res = handle_item(key, previous, result, None)
        case AbsAny():  # pragma: no cover
            raise Exception(f&#34;Cannot handle instance of type &#39;{type(item).__name__}&#39;.&#34;)
        case _ if str(type(item)) == &#34;&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;&#34;:
            from hdict.dataset.pandas_handling import explode_df

            # todo: check if this is the best default way of handling DFs.
            df = item.copy(deep=False)
            d = explode_df(df)
            df.__dict__[&#34;ashdict&#34;] = d
            res = value(df, hosh=d.hosh.rev, hdict=d)
        case _:
            res = value(item)

    if isinstance(key, tuple):
        return handle_multioutput(key, res, result, previous)
    elif not isinstance(key, str):  # pragma: no cover
        raise Exception(f&#34;Invalid type for input field specification: {type(key).__name__}&#34;)
    # elif key.startswith(&#34;_&#34;):  # pragma: no cover     # reminder: _* allowed here due to parameter name in getattr(__o)
    #     raise Exception(f&#34;Field names cannot start with &#39;_&#39;: {key}&#34;)

    return res


def handle_identity(data):
    hosh = ø
    ids, later = {}, {}
    for k, v in data.items():
        # Handle meta. mirror, and field ids differently.
        if k.startswith(&#34;_&#34;):  # pragma: no cover
            raise Exception(&#34;Custom metafields are not allowed:&#34;, k)
            # self.mhosh += self.data[k].hosh * k.encode()                # self.mids[k] = self.data[k].hosh.id
        elif k.endswith(&#34;_&#34;):
            # mirrorfield, e.g.: &#39;df_&#39; is a mirror/derived from &#39;df&#39;
            later[k] = v.id
        else:
            ids[k] = v.hosh.id
        hosh += v.hosh * k.encode()
        # todo:  PAPER REMINDER: state in the paper that identifiers are not strings. they are a special type that never appears as a value.
        #   I.e., hash(identifier) must be different from hash(value), for all identifiers and values.
        #   E.g.: hash(field name X) != hash(string &#34;X&#34;)
        #   In this impementation, the difference is always* true because values are always pickled (they are never hashed as strings), while identifiers are just str.encoded().
        #   * → probabilistically
    ids.update(later)
    return hosh, ids


def handle_multioutput(field_names: tuple, entry: AbsEntry | apply, previous_result, previous):
    &#34;&#34;&#34;Fields and hoshes are assigned to each output according to the alphabetical order of the original keys.

    &gt;&gt;&gt; from hdict import field, value
    &gt;&gt;&gt; d = {&#34;a&#34;: field(&#34;b&#34;), &#34;b&#34;: field(&#34;c&#34;), &#34;c&#34;: 5}
    &gt;&gt;&gt; d
    {&#39;a&#39;: field(b), &#39;b&#39;: field(c), &#39;c&#39;: 5}
    &gt;&gt;&gt; handle_multioutput((&#34;x&#34;,&#34;y&#34;), value([0, 1]), d, None)
    {&#39;x&#39;: 0, &#39;y&#39;: 1}
    &gt;&gt;&gt; handle_multioutput((&#34;x&#34;,&#34;y&#34;), value({1: &#34;a&#34;, 0: &#34;b&#34;}), d, None)
    {&#39;x&#39;: &#39;b&#39;, &#39;y&#39;: &#39;a&#39;}
    &#34;&#34;&#34;
    from hdict import value
    from hdict.content.entry.subvalue import SubValue

    data = {}
    match entry:
        case value(value=list() as lst):
            if len(field_names) != len(lst):  # pragma: no cover
                raise Exception(f&#34;Number of output fields (&#39;{len(field_names)}&#39;) should match number of list elements (&#39;{len(lst)}&#39;).&#34;)
            for field_name, val in zip(field_names, lst):
                data[field_name] = handle_item(field_name, val, previous_result, previous)
        case value(value=dict() as dct):
            if len(field_names) != len(dct):  # pragma: no cover
                raise Exception(f&#34;Number of output fields (&#39;{len(field_names)}&#39;) should match number of dict entries (&#39;{len(dct)}&#39;).&#34;)
            for field_name, (_, val) in zip(field_names, sorted(dct.items())):
                data[field_name] = handle_item(field_name, val, previous_result, previous)
        case AbsEntry() | apply():
            keys = []  # For repr().
            parent = Closure(entry, previous_result, keys, previous) if isinstance(entry, apply) else entry
            n = len(field_names)
            for key, i, source in loop_field_names(field_names):
                if key is not None:
                    keys.append(key)
                    data[key] = SubValue(parent, i, n, source)
        case _:  # pragma: no cover
            raise Exception(f&#34;Cannot handle multioutput for key &#39;{field_names}&#39; and type &#39;{type(entry).__name__}&#39;.&#34;)
    return data


def loop_field_names(field_names):
    if all(isinstance(x, tuple) for x in field_names):
        source_target = sorted((sour, targ) for targ, sour in field_names)
        for i, sour_targ in enumerate(source_target):
            if len(sour_targ) != 2:  # pragma: no cover
                raise Exception(f&#34;Output tuples should be string pairs &#39;target=source&#39;, not a sequence of length &#39;{len(sour_targ)}&#39;.&#34;, sour_targ)
            source, target = sour_targ
            yield target, i, source
    elif any(isinstance(x, tuple) for x in field_names):  # pragma: no cover
        raise Exception(f&#34;Cannot mix translated and non translated outputs.&#34;, field_names)
    else:
        for i, field_name in enumerate(field_names):
            yield field_name, i, None


# def handle_mirror(k, data, id, kind, previous):  # object | Cached
#     from hdict.content.entry.cached import Cached
#
#     if not isinstance(data[k], (Cached, frozenhdict)):  # pragma: no cover
#         raise Exception(f&#34;Cannot handle fetched object of type `{type(data[k])}`&#34;)
#     match kind:
#         case &#34;&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;&#34;:
#             f = lambda **kwargs: kwargs[k].asdf
#             return apply(f, fhosh=ø, **{k: field(k)}).enclosure(data, k, previous)
#         case None:  # pragma: no cover
#             pass
#         case _:  # pragma: no cover
#             raise Exception(f&#34;Unknown mirror field kind `{kind}`.&#34;)


def handle_format(format, fields, df, name):
    &#34;&#34;&#34;
    &gt;&gt;&gt; from hdict import hdict
    &gt;&gt;&gt; df = hdict(index=[1,2], X=[3,4], y=[5,6]).asdf
    &gt;&gt;&gt; handle_format(&#34;Xy&#34;, [&#34;X&#34;, &#34;y&#34;], df, True).show(colored=False)
    {
        X: &#34;‹{&#39;X&#39;: {1: 3, 2: 4}}›&#34;,
        y: &#34;‹[0 1]›&#34;,
        name: true,
        _id: rd.NmqV3FPKd3o5c7XAcPcJ6GFkK7O5XSAZR7JkV,
        _ids: {
            X: OMVTYSyh4Tl7V-eDNkbZ.1j79E5eLBOPLtXB.87w,
            y: cm5S71YBRAlVWV5Yn9pXHzsacyZuEH4ZFDNAw9nu,
            name: oK8X-7eG1Qp1WH7v6fokBDrQPdngKn.h86tlEnx4
        }
    }
    &gt;&gt;&gt; handle_format(&#34;df&#34;, [&#34;X&#34;, &#34;y&#34;], df, True).show(colored=False)
    {
        df: &#34;‹{&#39;X&#39;: {1: 3, 2: 4}, &#39;y&#39;: {1: 5, 2: 6}}›&#34;,
        name: true,
        _id: VWDHscqLlIW-Fu6bOAjrEBHzUehukqBOxK3RM4m9,
        _ids: {
            df: wTtDSUgXcZQVqx-CBZI-L9h4zVjAazPRGQOUNza8,
            name: oK8X-7eG1Qp1WH7v6fokBDrQPdngKn.h86tlEnx4
        }
    }
    &gt;&gt;&gt; handle_format(&#34;Xy&#34;, None, df, True).show(colored=False)
    {
        X: &#34;‹{&#39;X&#39;: {1: 3, 2: 4}}›&#34;,
        y: &#34;‹[0 1]›&#34;,
        name: true,
        _id: rd.NmqV3FPKd3o5c7XAcPcJ6GFkK7O5XSAZR7JkV,
        _ids: {
            X: OMVTYSyh4Tl7V-eDNkbZ.1j79E5eLBOPLtXB.87w,
            y: cm5S71YBRAlVWV5Yn9pXHzsacyZuEH4ZFDNAw9nu,
            name: oK8X-7eG1Qp1WH7v6fokBDrQPdngKn.h86tlEnx4
        }
    }
    &#34;&#34;&#34;
    if fields and not isinstance(fields, list):  # pragma: no cover
        raise Exception(f&#34;`fields` must be a list.&#34;)
    if fields is None:
        fields = [&#34;df&#34;]
    if format == &#34;df&#34;:
        if fields == [&#34;X&#34;, &#34;y&#34;]:
            fields = [&#34;df&#34;]
        if len(fields) != 1:  # pragma: no cover
            raise Exception(f&#34;Wrong number of fields {len(fields)}. Expected: 1.&#34;, fields)
        d = frozenhdict({fields[0]: df})
    elif format == &#34;Xy&#34;:
        if fields == [&#34;df&#34;]:
            fields = [&#34;X&#34;, &#34;y&#34;]
        if len(fields) != 2:  # pragma: no cover
            raise Exception(f&#34;Wrong number of fields {len(fields)}. Expected: 2.&#34;, fields)
        dic = df2Xy(df=df)
        d = frozenhdict({fields[0]: dic[&#34;X&#34;], fields[1]: dic[&#34;y&#34;]})
    else:  # pragma: no cover
        raise Exception(f&#34;Unknown {format=}.&#34;)

    if name:
        d &gt;&gt;= {&#34;name&#34;: name}
    return d</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="hdict.data.aux_frozendict.handle_format"><code class="name flex">
<span>def <span class="ident">handle_format</span></span>(<span>format, fields, df, name)</span>
</code></dt>
<dd>
<div class="desc"><pre><code class="language-python-repl">&gt;&gt;&gt; from hdict import hdict
&gt;&gt;&gt; df = hdict(index=[1,2], X=[3,4], y=[5,6]).asdf
&gt;&gt;&gt; handle_format(&quot;Xy&quot;, [&quot;X&quot;, &quot;y&quot;], df, True).show(colored=False)
{
    X: &quot;‹{'X': {1: 3, 2: 4}}›&quot;,
    y: &quot;‹[0 1]›&quot;,
    name: true,
    _id: rd.NmqV3FPKd3o5c7XAcPcJ6GFkK7O5XSAZR7JkV,
    _ids: {
        X: OMVTYSyh4Tl7V-eDNkbZ.1j79E5eLBOPLtXB.87w,
        y: cm5S71YBRAlVWV5Yn9pXHzsacyZuEH4ZFDNAw9nu,
        name: oK8X-7eG1Qp1WH7v6fokBDrQPdngKn.h86tlEnx4
    }
}
&gt;&gt;&gt; handle_format(&quot;df&quot;, [&quot;X&quot;, &quot;y&quot;], df, True).show(colored=False)
{
    df: &quot;‹{'X': {1: 3, 2: 4}, 'y': {1: 5, 2: 6}}›&quot;,
    name: true,
    _id: VWDHscqLlIW-Fu6bOAjrEBHzUehukqBOxK3RM4m9,
    _ids: {
        df: wTtDSUgXcZQVqx-CBZI-L9h4zVjAazPRGQOUNza8,
        name: oK8X-7eG1Qp1WH7v6fokBDrQPdngKn.h86tlEnx4
    }
}
&gt;&gt;&gt; handle_format(&quot;Xy&quot;, None, df, True).show(colored=False)
{
    X: &quot;‹{'X': {1: 3, 2: 4}}›&quot;,
    y: &quot;‹[0 1]›&quot;,
    name: true,
    _id: rd.NmqV3FPKd3o5c7XAcPcJ6GFkK7O5XSAZR7JkV,
    _ids: {
        X: OMVTYSyh4Tl7V-eDNkbZ.1j79E5eLBOPLtXB.87w,
        y: cm5S71YBRAlVWV5Yn9pXHzsacyZuEH4ZFDNAw9nu,
        name: oK8X-7eG1Qp1WH7v6fokBDrQPdngKn.h86tlEnx4
    }
}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_format(format, fields, df, name):
    &#34;&#34;&#34;
    &gt;&gt;&gt; from hdict import hdict
    &gt;&gt;&gt; df = hdict(index=[1,2], X=[3,4], y=[5,6]).asdf
    &gt;&gt;&gt; handle_format(&#34;Xy&#34;, [&#34;X&#34;, &#34;y&#34;], df, True).show(colored=False)
    {
        X: &#34;‹{&#39;X&#39;: {1: 3, 2: 4}}›&#34;,
        y: &#34;‹[0 1]›&#34;,
        name: true,
        _id: rd.NmqV3FPKd3o5c7XAcPcJ6GFkK7O5XSAZR7JkV,
        _ids: {
            X: OMVTYSyh4Tl7V-eDNkbZ.1j79E5eLBOPLtXB.87w,
            y: cm5S71YBRAlVWV5Yn9pXHzsacyZuEH4ZFDNAw9nu,
            name: oK8X-7eG1Qp1WH7v6fokBDrQPdngKn.h86tlEnx4
        }
    }
    &gt;&gt;&gt; handle_format(&#34;df&#34;, [&#34;X&#34;, &#34;y&#34;], df, True).show(colored=False)
    {
        df: &#34;‹{&#39;X&#39;: {1: 3, 2: 4}, &#39;y&#39;: {1: 5, 2: 6}}›&#34;,
        name: true,
        _id: VWDHscqLlIW-Fu6bOAjrEBHzUehukqBOxK3RM4m9,
        _ids: {
            df: wTtDSUgXcZQVqx-CBZI-L9h4zVjAazPRGQOUNza8,
            name: oK8X-7eG1Qp1WH7v6fokBDrQPdngKn.h86tlEnx4
        }
    }
    &gt;&gt;&gt; handle_format(&#34;Xy&#34;, None, df, True).show(colored=False)
    {
        X: &#34;‹{&#39;X&#39;: {1: 3, 2: 4}}›&#34;,
        y: &#34;‹[0 1]›&#34;,
        name: true,
        _id: rd.NmqV3FPKd3o5c7XAcPcJ6GFkK7O5XSAZR7JkV,
        _ids: {
            X: OMVTYSyh4Tl7V-eDNkbZ.1j79E5eLBOPLtXB.87w,
            y: cm5S71YBRAlVWV5Yn9pXHzsacyZuEH4ZFDNAw9nu,
            name: oK8X-7eG1Qp1WH7v6fokBDrQPdngKn.h86tlEnx4
        }
    }
    &#34;&#34;&#34;
    if fields and not isinstance(fields, list):  # pragma: no cover
        raise Exception(f&#34;`fields` must be a list.&#34;)
    if fields is None:
        fields = [&#34;df&#34;]
    if format == &#34;df&#34;:
        if fields == [&#34;X&#34;, &#34;y&#34;]:
            fields = [&#34;df&#34;]
        if len(fields) != 1:  # pragma: no cover
            raise Exception(f&#34;Wrong number of fields {len(fields)}. Expected: 1.&#34;, fields)
        d = frozenhdict({fields[0]: df})
    elif format == &#34;Xy&#34;:
        if fields == [&#34;df&#34;]:
            fields = [&#34;X&#34;, &#34;y&#34;]
        if len(fields) != 2:  # pragma: no cover
            raise Exception(f&#34;Wrong number of fields {len(fields)}. Expected: 2.&#34;, fields)
        dic = df2Xy(df=df)
        d = frozenhdict({fields[0]: dic[&#34;X&#34;], fields[1]: dic[&#34;y&#34;]})
    else:  # pragma: no cover
        raise Exception(f&#34;Unknown {format=}.&#34;)

    if name:
        d &gt;&gt;= {&#34;name&#34;: name}
    return d</code></pre>
</details>
</dd>
<dt id="hdict.data.aux_frozendict.handle_identity"><code class="name flex">
<span>def <span class="ident">handle_identity</span></span>(<span>data)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_identity(data):
    hosh = ø
    ids, later = {}, {}
    for k, v in data.items():
        # Handle meta. mirror, and field ids differently.
        if k.startswith(&#34;_&#34;):  # pragma: no cover
            raise Exception(&#34;Custom metafields are not allowed:&#34;, k)
            # self.mhosh += self.data[k].hosh * k.encode()                # self.mids[k] = self.data[k].hosh.id
        elif k.endswith(&#34;_&#34;):
            # mirrorfield, e.g.: &#39;df_&#39; is a mirror/derived from &#39;df&#39;
            later[k] = v.id
        else:
            ids[k] = v.hosh.id
        hosh += v.hosh * k.encode()
        # todo:  PAPER REMINDER: state in the paper that identifiers are not strings. they are a special type that never appears as a value.
        #   I.e., hash(identifier) must be different from hash(value), for all identifiers and values.
        #   E.g.: hash(field name X) != hash(string &#34;X&#34;)
        #   In this impementation, the difference is always* true because values are always pickled (they are never hashed as strings), while identifiers are just str.encoded().
        #   * → probabilistically
    ids.update(later)
    return hosh, ids</code></pre>
</details>
</dd>
<dt id="hdict.data.aux_frozendict.handle_item"><code class="name flex">
<span>def <span class="ident">handle_item</span></span>(<span>key, item, result, previous)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_item(key, item, result, previous):
    from hdict.content.argument.entry import entry

    match item:
        case AbsEntry():
            res = item
        case field(name=name):
            if name not in result:  # pragma: no cover
                raise MissingFieldException(f&#34;Missing field `{name}`&#34;)
            res = handle_item(name, result[name], result, previous)
        case entry(name=name):
            from hdict.content.entry.wrapper import Wrapper

            if name not in result:  # pragma: no cover
                raise MissingFieldException(f&#34;Missing entry `{name}`&#34;)
            res = Wrapper(handle_item(name, result[name], result, previous))
        case apply():
            res = item.enclosure(result, key, previous)
        case sample():  # pragma: no cover
            raise Exception(f&#34;Unsampled variable or argument `{key}`&#34;)
        case frozenhdict():
            res = value(item, item.hosh)
        case hdict():
            res = value(item.frozen, item.hosh)
        case ApplyOut():  # pragma: no cover
            raise Exception(&#34;Cannot assign output through both apply and dict-key: &#39;&gt;&gt; {out: apply(...)(out)}&#39;.&#34;)
        case Self():
            if previous is None:
                raise Exception(f&#34;Cannot reference self in a new hdict. `_` is intended to point to a hdict before application.&#34;)
            res = handle_item(key, previous, result, None)
        case AbsAny():  # pragma: no cover
            raise Exception(f&#34;Cannot handle instance of type &#39;{type(item).__name__}&#39;.&#34;)
        case _ if str(type(item)) == &#34;&lt;class &#39;pandas.core.frame.DataFrame&#39;&gt;&#34;:
            from hdict.dataset.pandas_handling import explode_df

            # todo: check if this is the best default way of handling DFs.
            df = item.copy(deep=False)
            d = explode_df(df)
            df.__dict__[&#34;ashdict&#34;] = d
            res = value(df, hosh=d.hosh.rev, hdict=d)
        case _:
            res = value(item)

    if isinstance(key, tuple):
        return handle_multioutput(key, res, result, previous)
    elif not isinstance(key, str):  # pragma: no cover
        raise Exception(f&#34;Invalid type for input field specification: {type(key).__name__}&#34;)
    # elif key.startswith(&#34;_&#34;):  # pragma: no cover     # reminder: _* allowed here due to parameter name in getattr(__o)
    #     raise Exception(f&#34;Field names cannot start with &#39;_&#39;: {key}&#34;)

    return res</code></pre>
</details>
</dd>
<dt id="hdict.data.aux_frozendict.handle_items"><code class="name flex">
<span>def <span class="ident">handle_items</span></span>(<span>*datas: [typing.Dict[str, object]], previous: <a title="hdict.data.frozenhdict.frozenhdict" href="frozenhdict.html#hdict.data.frozenhdict.frozenhdict">frozenhdict</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_items(*datas: [Dict[str, object]], previous: frozenhdict):
    result = {} if previous is None else previous.raw.copy()
    result__mirror_fields = {}
    for key, item in chain(*(data.items() for data in datas)):
        entry = handle_item(key, item, result, previous)
        if isinstance(key, str) and key.endswith(&#34;_&#34;):
            if isinstance(entry, value):
                result__mirror_fields[f&#34;{key[:-1]}&#34;] = value(entry.hdict, entry.hdict.hosh)
            else:
                raise Exception(f&#34;lazy mirror?&#34;)  # todo:
        if isinstance(entry, dict):
            result.update(entry)
        else:
            result[key] = entry
    result.update(result__mirror_fields)
    return result</code></pre>
</details>
</dd>
<dt id="hdict.data.aux_frozendict.handle_multioutput"><code class="name flex">
<span>def <span class="ident">handle_multioutput</span></span>(<span>field_names: tuple, entry: <a title="hdict.content.entry.AbsEntry" href="../content/entry/index.html#hdict.content.entry.AbsEntry">AbsEntry</a> | <a title="hdict.content.argument.apply.apply" href="../content/argument/apply.html#hdict.content.argument.apply.apply">apply</a>, previous_result, previous)</span>
</code></dt>
<dd>
<div class="desc"><p>Fields and hoshes are assigned to each output according to the alphabetical order of the original keys.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from hdict import field, value
&gt;&gt;&gt; d = {&quot;a&quot;: field(&quot;b&quot;), &quot;b&quot;: field(&quot;c&quot;), &quot;c&quot;: 5}
&gt;&gt;&gt; d
{'a': field(b), 'b': field(c), 'c': 5}
&gt;&gt;&gt; handle_multioutput((&quot;x&quot;,&quot;y&quot;), value([0, 1]), d, None)
{'x': 0, 'y': 1}
&gt;&gt;&gt; handle_multioutput((&quot;x&quot;,&quot;y&quot;), value({1: &quot;a&quot;, 0: &quot;b&quot;}), d, None)
{'x': 'b', 'y': 'a'}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_multioutput(field_names: tuple, entry: AbsEntry | apply, previous_result, previous):
    &#34;&#34;&#34;Fields and hoshes are assigned to each output according to the alphabetical order of the original keys.

    &gt;&gt;&gt; from hdict import field, value
    &gt;&gt;&gt; d = {&#34;a&#34;: field(&#34;b&#34;), &#34;b&#34;: field(&#34;c&#34;), &#34;c&#34;: 5}
    &gt;&gt;&gt; d
    {&#39;a&#39;: field(b), &#39;b&#39;: field(c), &#39;c&#39;: 5}
    &gt;&gt;&gt; handle_multioutput((&#34;x&#34;,&#34;y&#34;), value([0, 1]), d, None)
    {&#39;x&#39;: 0, &#39;y&#39;: 1}
    &gt;&gt;&gt; handle_multioutput((&#34;x&#34;,&#34;y&#34;), value({1: &#34;a&#34;, 0: &#34;b&#34;}), d, None)
    {&#39;x&#39;: &#39;b&#39;, &#39;y&#39;: &#39;a&#39;}
    &#34;&#34;&#34;
    from hdict import value
    from hdict.content.entry.subvalue import SubValue

    data = {}
    match entry:
        case value(value=list() as lst):
            if len(field_names) != len(lst):  # pragma: no cover
                raise Exception(f&#34;Number of output fields (&#39;{len(field_names)}&#39;) should match number of list elements (&#39;{len(lst)}&#39;).&#34;)
            for field_name, val in zip(field_names, lst):
                data[field_name] = handle_item(field_name, val, previous_result, previous)
        case value(value=dict() as dct):
            if len(field_names) != len(dct):  # pragma: no cover
                raise Exception(f&#34;Number of output fields (&#39;{len(field_names)}&#39;) should match number of dict entries (&#39;{len(dct)}&#39;).&#34;)
            for field_name, (_, val) in zip(field_names, sorted(dct.items())):
                data[field_name] = handle_item(field_name, val, previous_result, previous)
        case AbsEntry() | apply():
            keys = []  # For repr().
            parent = Closure(entry, previous_result, keys, previous) if isinstance(entry, apply) else entry
            n = len(field_names)
            for key, i, source in loop_field_names(field_names):
                if key is not None:
                    keys.append(key)
                    data[key] = SubValue(parent, i, n, source)
        case _:  # pragma: no cover
            raise Exception(f&#34;Cannot handle multioutput for key &#39;{field_names}&#39; and type &#39;{type(entry).__name__}&#39;.&#34;)
    return data</code></pre>
</details>
</dd>
<dt id="hdict.data.aux_frozendict.loop_field_names"><code class="name flex">
<span>def <span class="ident">loop_field_names</span></span>(<span>field_names)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loop_field_names(field_names):
    if all(isinstance(x, tuple) for x in field_names):
        source_target = sorted((sour, targ) for targ, sour in field_names)
        for i, sour_targ in enumerate(source_target):
            if len(sour_targ) != 2:  # pragma: no cover
                raise Exception(f&#34;Output tuples should be string pairs &#39;target=source&#39;, not a sequence of length &#39;{len(sour_targ)}&#39;.&#34;, sour_targ)
            source, target = sour_targ
            yield target, i, source
    elif any(isinstance(x, tuple) for x in field_names):  # pragma: no cover
        raise Exception(f&#34;Cannot mix translated and non translated outputs.&#34;, field_names)
    else:
        for i, field_name in enumerate(field_names):
            yield field_name, i, None</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="hdict.data.aux_frozendict.MissingFieldException"><code class="flex name class">
<span>class <span class="ident">MissingFieldException</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MissingFieldException(Exception):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="hdict.data" href="index.html">hdict.data</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="hdict.data.aux_frozendict.handle_format" href="#hdict.data.aux_frozendict.handle_format">handle_format</a></code></li>
<li><code><a title="hdict.data.aux_frozendict.handle_identity" href="#hdict.data.aux_frozendict.handle_identity">handle_identity</a></code></li>
<li><code><a title="hdict.data.aux_frozendict.handle_item" href="#hdict.data.aux_frozendict.handle_item">handle_item</a></code></li>
<li><code><a title="hdict.data.aux_frozendict.handle_items" href="#hdict.data.aux_frozendict.handle_items">handle_items</a></code></li>
<li><code><a title="hdict.data.aux_frozendict.handle_multioutput" href="#hdict.data.aux_frozendict.handle_multioutput">handle_multioutput</a></code></li>
<li><code><a title="hdict.data.aux_frozendict.loop_field_names" href="#hdict.data.aux_frozendict.loop_field_names">loop_field_names</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="hdict.data.aux_frozendict.MissingFieldException" href="#hdict.data.aux_frozendict.MissingFieldException">MissingFieldException</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>